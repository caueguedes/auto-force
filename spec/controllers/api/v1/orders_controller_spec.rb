require 'rails_helper'
require 'pry'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.
#
# Also compared to earlier versions of this generator, there are no longer any
# expectations of assigns and templates rendered. These features have been
# removed from Rails core in Rails 5, but can be added back in via the
# `rails-controller-testing` gem.

RSpec.describe Api::V1::OrdersController, type: :controller do

  # This should return the minimal set of attributes required to create a valid
  # Order. As you add validations to Order, be sure to
  # adjust the attributes here as well.
  let(:valid_attributes) {
    build(:order).as_json.except("created_at", "updated_at", "id")
  }

  let(:invalid_attributes) {  { "reference": "BR102030" } }

  # This should return the minimal set of values that should be in the session
  # in order to pass any filters (e.g. authentication) defined in
  # OrdersController. Be sure to keep this updated too.
  let(:valid_session) { {} }

  describe "POST orders#create" do
    context "with valid params" do
      it "creates a new Order" do
        expect { post :create, params: {order: valid_attributes } }.to change(Order, :count).by(1)
      end

      it "renders a JSON response with the new order" do
        post :create, params: { order: valid_attributes }
        expect(response).to have_http_status(:created)
        expect(response.content_type).to eq('application/json; charset=utf-8')
        expect(JSON.load response.body).to include_json( valid_attributes )
      end

      context "try to create twice the same order" do
        it 'returns reference already taken' do
          post :create, params: { order: valid_attributes }
          post :create, params: { order: valid_attributes }

          expect(response.content_type).to eq('application/json; charset=utf-8')
          expect(JSON.load response.body).to include_json({ error:  {
              reference: ['has already been taken']}})
        end
      end
    end

    context "without params" do
      it "renders a JSON response with error and unprocessable_entity status" do
        post :create
        expect(response).to have_http_status(:unprocessable_entity)
        expect(response.content_type).to eq('application/json; charset=utf-8')
        expect(JSON.load response.body).to include_json({ error: 'param is missing or the value is empty: order' })
      end
    end

    context "with partial params" do
      it "renders a JSON response with errors for the new order" do
        post :create, params: { order: invalid_attributes }
        expect(response).to have_http_status(:unprocessable_entity)
        expect(response.content_type).to eq('application/json; charset=utf-8')
        expect(JSON.load response.body).to include_json( JSON.load(IO.read'spec/controllers/responses/order_invalid.json' ))
      end
    end
  end

  describe "GET orders#check_status" do
    let!(:order1) { create(:order) }
    let!(:order2) { create(:order, reference: 'BR102031') }

    context 'without params' do
      it "returns a JSON response with error and unprocessable_entity response" do
        get 'check_status'
        expect(response).to have_http_status(:unprocessable_entity)
        expect(JSON.load response.body).to include_json({ error: 'param is missing or the value is empty: reference' })
      end
    end

    context 'with valid params' do
      context 'using reference' do
        it "returns a success response" do
          get 'check_status', params: { "reference": order1.reference}
          expect(response).to be_successful
          expect(JSON.load response.body).to include_json({data: [order1.as_json]})
        end
      end

      context 'using client_name' do
        it "returns a success response" do
          get 'check_status', params: {client_name: order1.client_name}
          expect(response).to be_successful
          expect(JSON.load response.body).to include_json({ data: [order1.as_json, order2.as_json] })
        end
      end
    end
  end

  describe "GET orders#list" do
    let!(:order1) { create(:order) }
    let!(:order2) { create(:order) }
    let!(:order3) { create(:order, purchase_channel: 'Site GER') }

    context 'with invalid parafilterms' do
      context 'with an invalid purchase_channel' do
        it "returns a Not Found response" do
          get 'list', params: { "purchase_channel": 'unknown'}
          expect(response).to have_http_status(:not_found)
          expect(JSON.load response.body).to include_json({ error: 'No Records Found' })
        end
      end
    end

    context 'with valid params' do
      context 'using purchase_channel' do
        it "returns a Not Found response" do
          get 'list', params: {purchase_channel: order1.purchase_channel}
          expect(response).to have_http_status(:not_found)
          expect(JSON.load response.body).to include_json({ error: 'No Records Found' })
        end

        context 'and status 0' do
          it "returns a success response" do
            get 'list', params: {purchase_channel: order1.purchase_channel, status: :published}
            expect(response).to be_successful
            expect(JSON.load response.body).to include_json({ data: [order1.as_json, order2.as_json] })
          end
        end
      end
    end
  end
end
